{"version":3,"sources":["../../src/lib/repeat.js"],"names":["randomArray","Array","makeNumber","repeat","provider","min","max","unique","count","console","warn","uniqueMap","attempts","i","val","map","Object","values"],"mappings":";;;;;;;;;AAAA;;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBO,IAAMA,oCAAc,iBAAQC,KAAR,EAAeC,gBAAf,CAApB;;AAEP;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BO,IAAMC,0BAAS,SAATA,MAAS,CAACC,QAAD,EAAWC,GAAX,EAAgBC,GAAhB;AAAA,SACpB,iBAAQ,aAAIF,QAAJ,CAAR,EAAuBJ,WAAvB,EAAoCK,GAApC,EAAyCC,GAAzC,CADoB;AAAA,CAAf;;AAGP;;;;;;;;;;;;;;;;;;;;;;;;;AAyBO,IAAMC,0BAAS,SAATA,MAAS,CAACH,QAAD,EAAWC,GAAX,EAAgBC,GAAhB,EAAwB;AAC5C,MAAME,QAAQF,MAAM,uBAAYD,GAAZ,EAAiBC,GAAjB,CAAN,GAA8BD,GAA5C;AACA,MAAI,QAAOD,UAAP,MAAsB,QAA1B,EAAoC;AAClCK,YAAQC,IAAR,CAAa,4CAAb;AACA,WAAOP,OAAOC,QAAP,EAAiBI,KAAjB,CAAP;AACD;AACD,MAAMG,YAAY,EAAlB;AACA,MAAIC,WAAW,CAAf;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIL,KAApB,EAA2BK,GAA3B,EAAgC;AAC9B;AACA,QAAMC,MAAMV,UAAZ;AACA;AACA;AACA,QAAIO,UAAUG,GAAV,CAAJ,EAAoBD;;AAEpB;AACA;AACAD;AACA;AACA;AACA,QAAIA,WAAWJ,QAAQ,CAAvB,EAA0B;;AAE1B;AACAO,YAAID,GAAJ,IAAWA,GAAX;AACD;AACD;AACA,SAAOE,OAAOC,MAAP,CAAcN,SAAd,CAAP;AACD,CA3BM","file":"repeat.js","sourcesContent":["import { compose, map } from 'lodash/fp'\nimport { randomRange, makeNumber } from './util'\n\n/**\n * Utilize the Array constructor to make an Array of empty values at a random\n * length. This can be used to then map over.\n *\n * ## Composition\n * `compose` will create a function that can take any number of arguments. Those arguments\n * will be passed first to `makeNumber`, which accepts 1 or 2 values. So `randomArray` can\n * accept 1 or 2 values.\n *\n * Calling `makeNumber` will create a single integer (which may be random, see `makeNumber` docs).\n * That integer is then passed to Array(int).\n *\n * Without using `compose` this function could look like:\n * const randomArray = (min, max) => Array(makeNumber(min, max));\n *\n * @example\n * // Empty array between 1 and 3\n * randomArray(1, 3) // [undefined, undefined]\n * // Empty array of length 2\n * randomArray(2) // [undefined, undefined]\n */\nexport const randomArray = compose(Array, makeNumber)\n\n/**\n * Function to generate an array of data. The `provider` argument is a function that when called,\n * returns any data. This function will then be called the number of times `count` is.\n *\n * The intention is that `provider` will return random data in order to create arrays of\n * unique values.\n *\n * ## Composition\n * @todo composition explaniation\n * @type {Repeater}\n * @param {function} provider - A function to call to create data. Will be called number of times\n *                             count is. The resulting value is added to the final array.\n * @param {number} min - Minimum number of items in the final array.\n * @param {number} [max] - Maximum number of items in the array.\n * @return {array}\n * @example <caption>The Provider function</caption>\n * // The function should return something random,\n * // this isn't helpful.\n * const notHelpfulProvider = () => ':(';\n * repeat(notHelpfulProvider, 3) // [':(', ':(', ':(']\n *\n * // Helpful provider returns unique values\n * const randomProvider = () => Math.round(Math.random() * 100)\n * repeat(randomProvider, 5) // [23, 56, 98, 12, 56]\n *\n */\nexport const repeat = (provider, min, max) =>\n  compose(map(provider), randomArray)(min, max)\n\n/**\n * Create an array of random data, but ensure that each value in the array is unique.\n *\n * It is possible that this function returns less data than asked for by `count`. An internal\n * check will cancel the creation loop if it takes too many tries to create unique random data.\n * @type {Reapeater}\n * @param {function} provider - A function to call to create data. Will be called number of times\n *                             count is. The resulting value is added to the final array.\n * @param {number} min - Minimum number of items in the final array.\n * @param {number} [max] - Maximum number of items in the array.\n * @return {array}\n * // Pick a random letter from the alphabet each time called\n * const abcProvider = arrayProvider(['A', 'B', 'C'...]);\n * abcProvider() // 'K'\n *\n * // repeat function may duplicated items\n * repeat(abcProvider, 5) // ['C', 'L', 'R', 'Q', 'R']\n * // unique will keep calling the provider until it creates the requested number of items...\n * unique(abcProvider, 5) // ['X', 'Q', 'G', 'P', 'T']\n *\n * // Unless you try to create a lot of data from a small source set.\n * // This will not likely create 20 letters randomly that are unique.\n * // This loop will exit before it reaches 20\n * unique(abcProvider, 20) // An array with less than 20 values\n */\nexport const unique = (provider, min, max) => {\n  const count = max ? randomRange(min, max) : min\n  if (typeof provider() === 'object') {\n    console.warn('unique doesnt support objects at this time')\n    return repeat(provider, count)\n  }\n  const uniqueMap = {}\n  let attempts = 0\n  for (let i = 0; i < count; i++) {\n    // Create the item\n    const val = provider()\n    // Check if item exists in the uniqueMap. If it does decrement this\n    // loop to create an item again.\n    if (uniqueMap[val]) i--\n\n    // Since the loop can decrement if a duplicate is created, keep track of\n    // how many times it actually ran so far.\n    attempts++\n    // Don't let this loop forever. If this has been trying to create unique values and cant\n    // after 2x the list length, exit loop and return less items\n    if (attempts > count * 2) break\n\n    // Assign created value as key and value in uniqueMap\n    map[val] = val\n  }\n  // Create an array out of uniqueMap\n  return Object.values(uniqueMap)\n}\n"]}